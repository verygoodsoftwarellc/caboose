# frozen_string_literal: true

require_relative "caboose/version"
require_relative "caboose/configuration"

require "opentelemetry/sdk"

require_relative "caboose/sqlite_exporter"
require_relative "caboose/source_location"
require_relative "caboose/metric_key"
require_relative "caboose/metric_storage"
require_relative "caboose/metric_span_processor"
require_relative "caboose/metric_flusher"
require_relative "caboose/backoff_policy"
require_relative "caboose/metric_submitter"

module Caboose
  class Error < StandardError; end

  MISSING_PARENT_ID = "0000000000000000"

  module_function

  def configuration
    @configuration ||= Configuration.new
  end

  def configure
    yield(configuration) if block_given?
  end

  def enabled?
    configuration.enabled
  end

  def exporter
    @exporter ||= SQLiteExporter.new(configuration.database_path)
  end

  def exporter=(exporter)
    @exporter = exporter
  end

  def span_processor
    @span_processor ||= OpenTelemetry::SDK::Trace::Export::BatchSpanProcessor.new(
      exporter,
      max_queue_size: 1000,
      max_export_batch_size: 100,
      schedule_delay: 1000 # 1 second
    )
  end

  def span_processor=(span_processor)
    @span_processor = span_processor
  end

  def tracer
    @tracer ||= OpenTelemetry.tracer_provider.tracer("Caboose", Caboose::VERSION)
  end

  def untraced(&block)
    OpenTelemetry::Common::Utilities.untraced(&block)
  end

  def metric_storage
    @metric_storage
  end

  def metric_storage=(storage)
    @metric_storage = storage
  end

  def metric_flusher
    @metric_flusher
  end

  def metric_flusher=(flusher)
    @metric_flusher = flusher
  end

  # Manually flush metrics (useful for testing or forced flushes).
  def flush_metrics
    @metric_flusher&.flush_now || 0
  end

  # Re-initialize metric flusher after fork.
  # Call this from Puma/Unicorn after_fork hooks.
  def after_fork
    @metric_flusher&.after_fork
  end

  # Configure OpenTelemetry with selected instrumentations
  def configure_opentelemetry
    return if @otel_configured

    # Suppress noisy OTel INFO logs
    OpenTelemetry.logger = Logger.new($stdout, level: Logger::WARN)

    service_name = if defined?(Rails) && Rails.application
      Rails.application.class.module_parent_name.underscore rescue "rails_app"
    else
      "app"
    end

    # Require only the instrumentations we want
    require "opentelemetry-instrumentation-rack"
    require "opentelemetry-instrumentation-net_http"
    require "opentelemetry-instrumentation-active_support"
    require "opentelemetry-instrumentation-action_pack" if defined?(ActionController)
    require "opentelemetry-instrumentation-action_view" if defined?(ActionView)
    require "opentelemetry-instrumentation-active_job" if defined?(ActiveJob)

    OpenTelemetry::SDK.configure do |c|
      c.service_name = service_name

      # Spans: detailed trace data stored in SQLite
      if configuration.spans_enabled
        c.add_span_processor(span_processor)
      end

      # Metrics: lightweight aggregation in memory, submitted via HTTP periodically
      if configuration.metrics_enabled
        @metric_storage = MetricStorage.new
        metric_processor = MetricSpanProcessor.new(storage: @metric_storage)
        c.add_span_processor(metric_processor)

        # Start background flusher if HTTP submission is configured
        if configuration.metrics_submission_configured?
          submitter = MetricSubmitter.new(
            endpoint: configuration.url,
            api_key: configuration.key
          )
          @metric_flusher = MetricFlusher.new(
            storage: @metric_storage,
            submitter: submitter,
            interval: configuration.metrics_flush_interval
          )
          @metric_flusher.start

          # Ensure graceful shutdown
          at_exit { @metric_flusher&.stop }
        end
      end

      # Configure specific instrumentations
      c.use "OpenTelemetry::Instrumentation::Rack",
        untraced_requests: ->(env) {
          request = Rack::Request.new(env)
          return true if request.path.start_with?("/caboose")

          configuration.ignore_request.call(request)
        }
      c.use "OpenTelemetry::Instrumentation::Net::HTTP"
      c.use "OpenTelemetry::Instrumentation::ActiveSupport"
      c.use "OpenTelemetry::Instrumentation::ActionPack" if defined?(ActionController)
      c.use "OpenTelemetry::Instrumentation::ActionView" if defined?(ActionView)
      c.use "OpenTelemetry::Instrumentation::ActiveJob" if defined?(ActiveJob)
    end

    # Subscribe to common ActiveSupport notification patterns
    # This captures SQL, cache, mailer, and custom notifications
    if configuration.spans_enabled
      subscribe_to_notifications
    end

    @otel_configured = true
  end

  # Payload transformers for different notification types
  NOTIFICATION_TRANSFORMERS = {
    "sql.active_record" => ->(payload) {
      attrs = {}
      attrs["db.statement"] = payload[:sql] if payload[:sql]
      attrs["name"] = payload[:name] if payload[:name]
      attrs["db.name"] = payload[:connection]&.pool&.db_config&.name rescue nil
      # Capture source location (app code that triggered this query)
      SourceLocation.add_to_attributes(attrs)
      attrs
    },
    "instantiation.active_record" => ->(payload) {
      attrs = {}
      attrs["record_count"] = payload[:record_count] if payload[:record_count]
      attrs["class_name"] = payload[:class_name] if payload[:class_name]
      attrs
    },
    "cache_read.active_support" => ->(payload) {
      store = payload[:store]
      store_name = store.is_a?(String) ? store : store&.class&.name
      { "key" => payload[:key]&.to_s, "hit" => payload[:hit], "store" => store_name }
    },
    "cache_write.active_support" => ->(payload) {
      store = payload[:store]
      store_name = store.is_a?(String) ? store : store&.class&.name
      { "key" => payload[:key]&.to_s, "store" => store_name }
    },
    "cache_delete.active_support" => ->(payload) {
      store = payload[:store]
      store_name = store.is_a?(String) ? store : store&.class&.name
      { "key" => payload[:key]&.to_s, "store" => store_name }
    },
    "cache_exist?.active_support" => ->(payload) {
      store = payload[:store]
      store_name = store.is_a?(String) ? store : store&.class&.name
      { "key" => payload[:key]&.to_s, "exist" => payload[:exist], "store" => store_name }
    },
    "cache_fetch_hit.active_support" => ->(payload) {
      store = payload[:store]
      store_name = store.is_a?(String) ? store : store&.class&.name
      { "key" => payload[:key]&.to_s, "store" => store_name }
    },
    "deliver.action_mailer" => ->(payload) {
      attrs = {}
      attrs["mailer"] = payload[:mailer] if payload[:mailer]
      attrs["message_id"] = payload[:message_id] if payload[:message_id]
      attrs["to"] = Array(payload[:to]).join(", ") if payload[:to]
      attrs["subject"] = payload[:subject] if payload[:subject]
      attrs
    },
    "process.action_mailer" => ->(payload) {
      attrs = {}
      attrs["mailer"] = payload[:mailer] if payload[:mailer]
      attrs["action"] = payload[:action] if payload[:action]
      attrs
    }
  }.freeze

  def subscribe_to_notifications
    NOTIFICATION_TRANSFORMERS.each do |pattern, transformer|
      OpenTelemetry::Instrumentation::ActiveSupport.subscribe(tracer, pattern, transformer)
    rescue => e
      # Ignore errors for patterns that don't exist
    end

    # Auto-subscribe to custom patterns (default: "app.*")
    # This lets users just do: ActiveSupport::Notifications.instrument("app.whatever") { }
    subscribe_to_custom_patterns
  end

  def subscribe_to_custom_patterns
    configuration.subscribe_patterns.each do |prefix|
      # Subscribe to all notifications starting with this prefix
      pattern = /\A#{Regexp.escape(prefix)}/
      default_transformer = ->(payload) {
        attrs = payload.transform_keys(&:to_s).select { |_, v|
          v.is_a?(String) || v.is_a?(Numeric) || v.is_a?(TrueClass) || v.is_a?(FalseClass)
        }
        SourceLocation.add_to_attributes(attrs)
        attrs
      }
      OpenTelemetry::Instrumentation::ActiveSupport.subscribe(tracer, pattern, default_transformer)
    end
  end

  # Subscribe to any ActiveSupport::Notification and create spans for it
  #
  # @param pattern [String, Regexp] The notification pattern to subscribe to
  # @param transformer [Proc, nil] Optional proc to transform payload into span attributes
  #   If nil, all payload keys become span attributes
  #
  # @example Subscribe to a custom notification
  #   Caboose.subscribe("my_service.call")
  #
  # @example Subscribe with custom attribute transformer
  #   Caboose.subscribe("stripe.charge") do |payload|
  #     { "charge_id" => payload[:id], "amount" => payload[:amount] }
  #   end
  #
  def subscribe(pattern, &transformer)
    transformer ||= ->(payload) {
      # Default: convert all payload keys to string attributes
      payload.transform_keys(&:to_s).transform_values(&:to_s)
    }
    OpenTelemetry::Instrumentation::ActiveSupport.subscribe(tracer, pattern, transformer)
  end

  # Instrument a block of code, creating a span that shows up in Caboose
  #
  # NOTE: This method only works when Caboose is loaded (typically development).
  # For instrumentation that works in all environments, use ActiveSupport::Notifications
  # directly and subscribe with Caboose.subscribe in your initializer.
  #
  # @param name [String] The name of the span (e.g., "my_service.call", "external_api.fetch")
  # @param attributes [Hash] Optional attributes to add to the span
  # @yield The block to instrument
  # @return The return value of the block
  #
  # @example Basic usage (dev only)
  #   Caboose.instrument("geocoding.lookup") do
  #     geocoder.lookup(address)
  #   end
  #
  # @example For all environments, use ActiveSupport::Notifications instead:
  #   # In your app code (works everywhere):
  #   ActiveSupport::Notifications.instrument("myapp.geocoding", address: addr) do
  #     geocoder.lookup(addr)
  #   end
  #
  #   # In config/initializers/caboose.rb (only loaded in dev):
  #   Caboose.subscribe("myapp.geocoding")
  #
  def instrument(name, attributes = {}, &block)
    return yield unless enabled?

    # Add source location
    location = SourceLocation.find
    if location
      attributes["code.filepath"] = location[:filepath]
      attributes["code.lineno"] = location[:lineno]
      attributes["code.function"] = location[:function] if location[:function]
    end

    tracer.in_span(name, attributes: attributes, kind: :internal) do |span|
      yield span
    end
  end

  def storage
    @storage ||= Storage::SQLite.new(configuration.database_path)
  end

  def reset_storage!
    @storage = nil
  end

  def reset!
    @configuration = nil
    @exporter = nil
    @span_processor = nil
    @tracer = nil
    @storage = nil
    @metric_flusher&.stop
    @metric_flusher = nil
    @metric_storage = nil
    @otel_configured = false
  end
end

require_relative "caboose/storage"
require_relative "caboose/engine" if defined?(Rails)
